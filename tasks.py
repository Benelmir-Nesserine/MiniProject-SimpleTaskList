# -*- coding: utf-8 -*-
"""tasks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1No4wKjAcbwZlNC_d04HDrPgV3DLD9IZ0

# Simple Task Manager (Manual Save Version)

Features: Add / View / Mark done / Save / Reload.

Auto-save removed. Tasks are saved ONLY when choosing option 4.
"""

#!/usr/bin/env python3


from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Any, Dict, List, TypedDict


# ---------------------------
# Configuration
# ---------------------------

TASKS_FILE = Path("tasks.json")
LOG_LEVEL = logging.INFO


class Task(TypedDict):
    title: str
    done: bool


def setup_logging() -> None:
    """Configure basic logging."""
    logging.basicConfig(
        level=LOG_LEVEL,
        format="%(levelname)s: %(message)s",
    )


# ---------------------------
# Persistence (JSON)
# ---------------------------

def _is_valid_task(obj: Any) -> bool:
    """Return True if obj looks like a valid Task."""
    if not isinstance(obj, dict):
        return False
    if set(obj.keys()) != {"title", "done"}:
        return False
    if not isinstance(obj["title"], str):
        return False
    if not isinstance(obj["done"], bool):
        return False
    return True


def load_tasks(filepath: Path = TASKS_FILE) -> List[Task]:
    """
    Load tasks from JSON file.

    - If file doesn't exist: return empty list.
    - If JSON is empty/corrupted: log warning and return empty list.
    - If JSON contains invalid entries: keep only valid tasks.
    """
    if not filepath.exists():
        return []

    try:
        raw = filepath.read_text(encoding="utf-8").strip()
        if raw == "":
            logging.warning("%s is empty. Starting with an empty list.", filepath.name)
            return []

        data: Any = json.loads(raw)
    except (OSError, json.JSONDecodeError) as exc:
        logging.warning("Could not load %s (%s). Starting with empty list.", filepath.name, exc)
        return []

    if not isinstance(data, list):
        logging.warning("%s must contain a JSON list. Starting with empty list.", filepath.name)
        return []

    cleaned: List[Task] = []
    for item in data:
        if _is_valid_task(item):
            cleaned.append(item)  # type: ignore[arg-type]
        else:
            logging.warning("Skipping invalid task entry in %s: %r", filepath.name, item)

    return cleaned


def save_tasks(tasks: List[Task], filepath: Path = TASKS_FILE) -> bool:
    """
    Save tasks to JSON file atomically.

    Returns True on success, False on failure.
    """
    tmp_path = filepath.with_suffix(filepath.suffix + ".tmp")
    try:
        tmp_path.write_text(json.dumps(tasks, indent=4, ensure_ascii=False), encoding="utf-8")
        tmp_path.replace(filepath)  # atomic on most systems
        return True
    except OSError as exc:
        logging.error("Could not save tasks to %s (%s).", filepath.name, exc)
        try:
            if tmp_path.exists():
                tmp_path.unlink()
        except OSError:
            pass
        return False


# ---------------------------
# UI Helpers
# ---------------------------

def _prompt_non_empty(prompt: str) -> str:
    """Prompt until the user enters a non-empty string."""
    while True:
        value = input(prompt).strip()
        if value:
            return value
        print("Error: input cannot be empty. Try again.")


def _prompt_int(prompt: str) -> int:
    """Prompt until the user enters a valid integer."""
    while True:
        raw = input(prompt).strip()
        try:
            return int(raw)
        except ValueError:
            print("Error: please enter a valid number.")


def display_menu() -> None:
    """Print the main menu."""
    print("\n--- Task Manager ---")
    print("1. Add Task")
    print("2. View Tasks")
    print("3. Mark Task as Done")
    print("4. Save Tasks")
    print("5. Reload Tasks")
    print("6. Exit")


def list_tasks(tasks: List[Task]) -> None:
    """Display all tasks in their stored order."""
    if not tasks:
        print("No tasks available.")
        return

    done_count = sum(1 for t in tasks if t["done"])
    print(f"Tasks: {len(tasks)} total | {done_count} done | {len(tasks) - done_count} pending\n")

    for idx, task in enumerate(tasks, start=1):
        status = "✔" if task["done"] else "✘"
        print(f"{idx}. [{status}] {task['title']}")


# ---------------------------
# Actions
# ---------------------------

def add_task(tasks: List[Task]) -> bool:
    """Add a new task. Returns True if tasks were modified."""
    title = _prompt_non_empty("Enter task title: ")
    tasks.append({"title": title, "done": False})
    print("Task added.")
    return True


def mark_task_done(tasks: List[Task]) -> bool:
    """Mark an existing task as done. Returns True if tasks were modified."""
    if not tasks:
        print("No tasks to update.")
        return False

    list_tasks(tasks)
    number = _prompt_int("Enter task number: ")

    if not 1 <= number <= len(tasks):
        print("Error: invalid task number.")
        return False

    if tasks[number - 1]["done"]:
        print("This task is already marked as done.")
        return False

    tasks[number - 1]["done"] = True
    print("Task marked as done.")
    return True


# ---------------------------
# Main Loop
# ---------------------------

def main() -> None:
    setup_logging()
    tasks = load_tasks()

    while True:
        display_menu()
        choice = input("Choose option: ").strip()

        modified = False

        if choice == "1":
            add_task(tasks)
        elif choice == "2":
            list_tasks(tasks)
        elif choice == "3":
            mark_task_done(tasks)
        elif choice == "4":
            ok = save_tasks(tasks)
            print("Tasks saved." if ok else "Save failed (see error above).")
        elif choice == "5":
            tasks = load_tasks()
            print("Tasks reloaded.")
        elif choice == "6":
            # Always attempt to save on exit (safe & expected)
            save_tasks(tasks)
            print("Goodbye!")
            break
        else:
            print("Invalid choice. Please select between 1 and 6.")

        # Auto-save after modifications (within requirements, not adding new features)
        if modified:
            save_tasks(tasks)


if __name__ == "__main__":
    main()

main()